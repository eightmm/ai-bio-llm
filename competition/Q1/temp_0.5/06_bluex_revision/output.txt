## 1-1. Incident A — Messy library traces, variable yield, poor qPCR efficiency

### Most likely root cause(s) (ranked) and support
**(1) PCR inhibitors carried through from cleanups (residual ethanol; chaotropic salts/PEG; guanidine; other wash carryover).**  
*Support from observations:* intermittently low **A260/230**, poor/variable qPCR efficiency, smeary elevated baseline on traces that *sometimes* improves after repeating cleanup—classic “inhibitor carryover” behavior.

**(2) Inconsistent bead-cleanup execution and/or bead-ratio handling causing variable recovery and heterogeneous byproducts.**  
*Support:* yield “jumps around,” occasional small peaks (adapter/partial products), inconsistent improvement after repeat cleanup (suggests variable handling rather than a single fixed reagent defect).

**(3) Compound failure: partial inhibitor carryover + over-/under-drying beads.**  
Over-drying can reduce recovery (lower yield) while under-drying increases inhibitors (PCR failure), yielding run-to-run variability and messy traces even with the “same protocol.”

### Key alternative hypotheses to consider (and why they are less/ more consistent)
- **Reagent degradation (e.g., PCR mix, RT enzyme, ligase):** would tend to affect all runs similarly unless storage/handling differs; does not directly explain low A260/230 or “cleanup repetition helps sometimes.”
- **Incorrect bead ratio / wrong ethanol concentration:** plausible and can create smear/size skew; consistent with operator variability even within one team.
- **Primer-dimer/adapter-dimer dominance:** would produce strong small peaks; here the main issue includes smear and qPCR inhibition signals.

### Next steps to confirm (using existing materials/QC; no new wet-lab experiments required)
1. **Cross-run correlation using existing run records**  
   - Compare **A260/230**, qPCR efficiency/replicate Ct spread, and trace “smear severity.”  
   - A consistent trend (low A260/230 → poor qPCR and smear) supports inhibitor carryover.
2. **Audit “cleanup-sensitive” handling variables from run notes**  
   - Bead ratio(s), ethanol concentration/prep date, wash count, aspiration technique, air-dry duration, elution time/volume, pellet disturbance.
3. **Inspect qPCR amplification curves (not just Ct)**  
   - Inhibition often shows delayed onset, reduced slope, and higher replicate divergence.

### Fixes (protocol amendments + execution) with actionable QC gates
**Protocol clarifications to add (or verify whether already present in `protocol.md`):**
1. **Bead wash/removal specificity**  
   - Define wash count and volumes (e.g., “2 × 80% EtOH washes, avoid pellet disturbance”).
2. **Drying endpoint + bounds** (prevents both under- and over-drying)  
   - Example gate: “air-dry on magnet until pellet is *matte* and no visible droplets remain (typically 3–7 min); **do not exceed 10–12 min**.”
3. **Elution handling**  
   - “After elution, re-magnetize and transfer supernatant without bead carryover.”

**QC gates (suggested starting thresholds; calibrate to internal historical successes):**
- **A260/230:** flag if **<1.5** (strong concern if **<1.0**), especially if paired with qPCR inefficiency.  
- **qPCR replicate spread:** flag if replicate Cts differ by **>0.5–0.7 Ct** at similar input.  
- **Trace artifacts:** flag if small-product peak area is large or baseline smear obscures main peak.

---

## 1-2. Incident B — Operator-dependent PCR success; extended bead air-dry rescues

### Most likely root cause(s)
**Residual ethanol after bead washes inhibiting PCR** (primary).  
*Support:* extending air-dry and careful ethanol removal rescues PCR without reagent changes.

### Alternative hypotheses (to explicitly rule in/out)
- **Operator-specific pipetting errors in PCR setup:** possible, but the direct rescue by extra drying points to ethanol carryover as the dominant driver.
- **Bead carryover into eluate:** can also inhibit PCR and varies by operator; often co-occurs with rushed transfers.

### Next steps to confirm (no new wet-lab required)
1. **Operator-stratified failure mapping**  
   - Identify which bead cleanup step precedes PCR failure (post-ligation, post-RT, etc.). If failures cluster immediately after a cleanup, inhibition is strongly implicated.
2. **Check whether “rescued” runs differ only by drying/aspiration technique**  
   - If yes, document as a critical control point.

### Fix (prevention-focused; make variability harder)
1. **Add “critical step” callouts in protocol at every bead cleanup**  
   - Must include: “remove all visible ethanol,” “matte pellet,” and “max dry time.”
2. **Operator checklist (mandatory fields)**  
   - Dry time (min), second aspiration performed (Y/N), pellet appearance (wet/shiny vs matte).
3. **Training calibration**  
   - A brief standardization session to align what “matte” and “no droplets” looks like, and to avoid overdrying.

---

## 1-3. Incident C — Broad fragment sizes (>40 nt), weak periodicity, more non-CDS mapping

### Most likely root cause(s) (ranked)
**(1) Incomplete nuclease digestion and/or ineffective monosome enrichment**, producing mixed fragment populations (longer protected fragments, RNP fragments, possibly disomes), which dilutes canonical 28–34 nt footprints and reduces 3-nt periodicity.  
*Support:* broad distribution with substantial **>40 nt** material + weak periodicity + increased non-CDS mapping.

**(2) Size-selection window too broad or incorrectly executed**, letting >40 nt fragments into the library.  
*Support:* explicit observation of substantial >40 nt material post-selection/QC.

### Alternative hypotheses that must be considered
- **Ribosome run-off during lysis (insufficient translation arrest):** can reduce periodicity and CDS enrichment even if fragment sizes look plausible; here the strong “>40 nt” signal still points first to digestion/selection.
- **Incorrect computational P-site assignment/offset:** can weaken apparent periodicity even in good data; must be checked by offset sweep (see below), especially on a toy single-transcript dataset.
- **Contamination with non-ribosomal RNA fragments (e.g., mRNA fragments not protected):** can increase non-CDS mapping and weaken periodicity; often co-occurs with under-digestion and loose size selection.

### Next steps to confirm (computational + review of existing wet-lab QC only)
1. **Length-stratified periodicity and enrichment (from existing FASTQ/BAM)**  
   - Compute periodicity separately for **28–34 nt** vs **>35–40 nt**.  
   - Compute CDS vs UTR/non-CDS mapping fraction by length bin.  
   - Diagnostic expectation: shorter reads show stronger CDS enrichment and periodicity; longer reads show weak/none.
2. **Offset sweep to rule out “wrong P-site offset”**  
   - Evaluate frame periodicity across a plausible offset range (e.g., 10–15 nt for 5′-based P-site), and report the best periodicity achieved. If no offset yields periodicity, biology/fragment heterogeneity is more likely than a pure offset error.
3. **Audit the protocol step that defines digestion conditions and the size-selection window**  
   - If `protocol.md` does not specify a tight selection window or provides ambiguous gel slice boundaries, that ambiguity is itself a protocol defect to correct.

### Fix (protocol + validation plan)
1. **Digestion control points (future preventive; recommended even if not feasible during competition)**  
   - Record RNase units, time, temperature, lot; recommend a one-time titration per lot/system.
2. **Hard size-selection acceptance gate**  
   - Suggested starting gate: **≥80%** of material in the intended footprint window; **<5–10%** above 40 nt before proceeding.
3. **Add an interpretability gate post-sequencing**  
   - Require measurable periodicity in canonical lengths before committing to deep sequencing.

---

## 1-4. Incident D — Dedup collapses to tiny number of molecules; extremely low UMI diversity

### Most likely root cause(s) (ranked)
**(1) Wrong UMI extraction (wrong offset, wrong read end, or extracting constant adapter bases).**  
*Support:* UMI histogram concentrated in a tiny set; uniqueness saturates early; dedup collapses most reads; downstream counts become unstable.

**(2) True low UMI complexity due to adapter synthesis/procurement error (degenerate “N” region not truly degenerate, truncations, or incorrect oligo).**  
*Support:* behavior is also consistent with non-random UMI composition; incident set includes oligo-spec issues elsewhere (Incident E).

### Alternative hypotheses to explicitly address
- **Over-aggressive deduplication key (e.g., dedup by position only, ignoring UMI, or collapsing multi-mappers incorrectly):** can artifactually collapse diversity. Confirm dedup key is (position + UMI) and, if applicable, strand and CIGAR-consistent start.
- **Very low input diversity / extreme PCR jackpotting:** possible but less likely if UMI region is truly random and input amount was moderate; still, must be distinguished from wrong parsing by inspecting raw reads.

### Next steps to confirm (FASTQ-only; required before trusting dedup)
These steps deliberately test *multiple* UMI-parsing hypotheses rather than assuming one.
1. **Extract candidate UMI windows under several hypotheses and compare complexity**
   - Hypothesis A: UMI at 5′ read start (first *L* bases).  
   - Hypothesis B: UMI immediately adjacent to an expected constant linker motif (protocol-specified).  
   - Hypothesis C: UMI at 3′ end before adapter (last *L* bases pre-trimming).
2. **For each hypothesis, compute:**
   - Unique UMI count vs total reads  
   - Top-UMI fraction (e.g., fraction of reads with the single most frequent UMI)  
   - Per-position base composition and entropy across UMI bases
3. **Decision logic (suggested QC thresholds; calibrate as needed):**
   - For UMI length ≥6 and a few hundred reads, expect **dozens to hundreds** of unique UMIs.  
   - Flag as “likely wrong parsing or bad oligo” if:
     - top UMI fraction **>10–20%**, or
     - per-position entropy is very low (e.g., bases nearly constant at multiple UMI positions).
4. **Protocol audit requirement**
   - Ensure `protocol.md` unambiguously defines: UMI length, which end of the read, and the constant flanking sequence(s). If absent/ambiguous, that is a protocol defect to correct.

### Fix (pipeline + protocol hardening)
1. **Protocol: define a single unambiguous read structure**
   - Specify UMI as “N…N” with exact length and exact placement relative to a constant sequence.
2. **Pipeline: enforce a mandatory UMI sanity-check report before dedup**
   - Report unique UMIs, top-UMI fraction, and base composition/entropy.
3. **If oligo is suspected**
   - Quarantine new adapter lots until a small pilot confirms UMI diversity (computationally, from the first sequencing reads).

---

## 1-5. Incident E — Short junk products; no ligation shift; expected linker prefix rare; new oligo paperwork differs

### Most likely root cause(s) (ranked)
**(1) Adapter/oligo specification mismatch with the ligation chemistry used in the protocol** (wrong molecule type, missing required terminal modifications, or poor purification causing truncations).  
*Support:* no ligation shift on gel; enzyme replacement does not rescue; expected linker prefix is rare in reads; paperwork differs in molecule type/modifications/purification.

**(2) Systematic ligation failure leading to PCR amplification of artifacts (adapter/primer dimers).**  
*Support:* final trace dominated by short products; R1 enriched for primer/adapter-like sequence rather than the expected ligated structure.

### Make the diagnosis actionable by tying it to the protocol’s ligation chemistry (conditional but specific)
To avoid circularity, the required adapter properties must be checked against `protocol.md`:
- **If the protocol uses a truncated RNA ligase 2–type 3′ ligation that requires a pre-adenylated adapter**: the adapter must be **5′-App (preadenylated)** and typically **3′-blocked** (to prevent adapter self-ligation), and the molecule type (DNA vs RNA) must match the enzyme’s intended substrate.  
- **If the protocol uses a ligase that requires a 5′ phosphate on the ligated substrate**: ordering an oligo lacking **5′-phosphate** (or having incompatible blocks) can prevent ligation.  
Because the incident explicitly mentions “molecule type (RNA vs DNA), terminal modifications, or purification grade,” the highest-probability failure is an adapter ordered without the required modification(s) or with the wrong chemistry.

### Next steps to confirm (no new wet-lab required)
1. **Paperwork/spec reconciliation (old successful lot vs new lot)**
   - Confirm: exact sequence (including Ns), molecule type, required 5′/3′ modifications, purification (HPLC/PAGE vs desalted).
2. **FASTQ structure check**
   - Quantify frequency of the protocol-expected linker prefix.  
   - If linker prefix is rare while primer-like prefixes dominate, this strongly supports ligation/library-structure failure.
3. **Gel evidence re-interpretation**
   - The absence of a shifted band immediately after ligation is direct evidence that the adapter is not ligating under the specified conditions.

### Fix and prevention plan
1. **Protocol: include an “Adapter ordering specification” block**
   - Must list: molecule type, required 5′/3′ modifications, purification grade, and the intended constant linker sequence used for downstream parsing/QC.
2. **Incoming oligo QC gate (administrative + computational)**
   - Administrative: verify paperwork matches the ordering block.  
   - Computational: after a small pilot sequencing run, require **high linker-prefix rate** (suggested starting gate: **>80%** of reads show expected prefix after trimming/processing).
3. **Add an explicit “ligation success check” stop/go**
   - If denaturing gel shows no detectable shifted ligation product, stop before PCR.

---

## 1-6. Preliminary data analysis — Per-position footprint count array + single-transcript QC summary

### Deliverables required
- `counts_raw.csv` and `counts_dedup.csv` (per-position 5′-start counts)
- Histogram plot of 5′ start positions (raw vs dedup)
- Single HTML report summarizing QC + interpretation for this single transcript
- Written interpretation + 2–4 concrete follow-up checks

### Coordinate convention (explicit and used throughout)
- Reference: `reference.fa`, transcript id `toy_gene`.
- **Transcript coordinate system:** 1-based positions along the FASTA sequence.
- **Counted signal:** the **5′ alignment start** position on the transcript for each mapped read (after adapter trimming).  
  - For a mapped read with 0-based `ref_start`, the counted position is `position_1based = ref_start + 1`.

### Required implementation note (to keep results verifiable)
This environment does not provide executable access to `reads.fastq.gz`, `reference.fa`, or `protocol.md`; therefore, the only scientifically defensible way to satisfy the deliverable requirements here is to provide a **fully specified, deterministic pipeline** that (i) derives UMI/adapter handling from `protocol.md`, (ii) produces the exact required files, and (iii) emits a self-contained HTML report capturing all assumptions and QC metrics. The pipeline below is designed for the toy setting (single transcript; few hundred reads) and avoids hidden dependencies.

---

### A. Reproducible pipeline to generate `counts_raw.csv`, `counts_dedup.csv`, plot, and HTML

#### Inputs
- `reference.fa`
- `reads.fastq.gz`
- `protocol.md` (used only to fill in adapter/linker and UMI structure parameters)

#### Outputs
- `counts_raw.csv`
- `counts_dedup.csv`
- `starts_hist_raw_vs_dedup.png`
- `report.html`

#### Parameterization required from `protocol.md` (must be filled explicitly)
- `UMI_LENGTH` (integer)
- `UMI_LOCATION` (one of: `"5prime"`, `"3prime"`, `"adjacent_to_linker"`)
- `LINKER_SEQ` (constant sequence expected near the UMI/insert boundary; may be empty if not applicable)
- `ADAPTER_3P_SEQ` (3′ adapter sequence for trimming; may be inferred if protocol omits it, but that should be stated)

#### Single-file Python script (toy-aligner + UMI QC + outputs)
Save as `toy_riboseq_single_transcript.py` and run:
```bash
python toy_riboseq_single_transcript.py \
  --reference reference.fa \
  --fastq reads.fastq.gz \
  --umi_length <FILL_FROM_PROTOCOL> \
  --umi_location <FILL_FROM_PROTOCOL> \
  --linker_seq <FILL_FROM_PROTOCOL_OR_EMPTY> \
  --adapter3 <FILL_FROM_PROTOCOL_OR_EMPTY> \
  --max_mismatches 2
```

```python
import argparse, gzip, re, math
from collections import Counter, defaultdict
import matplotlib.pyplot as plt
import pandas as pd

def read_fasta_one(path):
    name, seq = None, []
    with open(path) as f:
        for line in f:
            line=line.strip()
            if not line: continue
            if line.startswith(">"):
                name = line[1:].split()[0]
            else:
                seq.append(line.upper())
    return name, "".join(seq)

def iter_fastq(path):
    opener = gzip.open if path.endswith(".gz") else open
    with opener(path, "rt") as f:
        while True:
            h = f.readline().rstrip()
            if not h: break
            s = f.readline().rstrip().upper()
            plus = f.readline().rstrip()
            q = f.readline().rstrip()
            yield h, s, q

def trim_adapter_3p(seq, adapter3):
    if not adapter3:
        return seq
    i = seq.find(adapter3)
    return seq if i == -1 else seq[:i]

def extract_umi(seq, umi_length, umi_location, linker_seq):
    # Returns (umi, insert_seq, flags)
    flags = []
    if umi_length <= 0:
        return "", seq, flags

    if umi_location == "5prime":
        if len(seq) < umi_length:
            return "", "", ["too_short_for_umi"]
        return seq[:umi_length], seq[umi_length:], flags

    if umi_location == "3prime":
        if len(seq) < umi_length:
            return "", "", ["too_short_for_umi"]
        return seq[-umi_length:], seq[:-umi_length], flags

    if umi_location == "adjacent_to_linker":
        if not linker_seq:
            return "", seq, ["missing_linker_seq_param"]
        j = seq.find(linker_seq)
        if j == -1:
            return "", seq, ["linker_not_found"]
        # assume UMI immediately upstream of linker
        start = j - umi_length
        if start < 0:
            return "", seq, ["linker_found_but_no_room_for_umi"]
        umi = seq[start:j]
        insert_seq = seq[:start] + seq[j+len(linker_seq):]
        return umi, insert_seq, flags

    return "", seq, ["unknown_umi_location"]

def best_align_start(read, ref, max_mismatches=2):
    # naive sliding-window alignment to single transcript
    m = len(read)
    best = None
    for i in range(0, len(ref)-m+1):
        mism = sum(1 for a,b in zip(read, ref[i:i+m]) if a!=b)
        if mism <= max_mismatches:
            if best is None or mism < best[0]:
                best = (mism, i)
                if mism == 0:
                    break
    return None if best is None else best[1]  # 0-based start

def entropy_base_counts(c):
    tot = sum(c.values())
    if tot == 0: return 0.0
    H = 0.0
    for b in "ACGT":
        p = c.get(b,0)/tot
        if p>0: H -= p*math.log(p,2)
    return H

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--reference", required=True)
    ap.add_argument("--fastq", required=True)
    ap.add_argument("--umi_length", type=int, required=True)
    ap.add_argument("--umi_location", required=True, choices=["5prime","3prime","adjacent_to_linker"])
    ap.add_argument("--linker_seq", default="")
    ap.add_argument("--adapter3", default="")
    ap.add_argument("--max_mismatches", type=int, default=2)
    args = ap.parse_args()

    tid, ref = read_fasta_one(args.reference)

    raw_counts = Counter()
    dedup_counts = Counter()
    umi_hist = Counter()
    umi_pos_counts = [Counter() for _ in range(args.umi_length)]
    linker_found = 0
    total = 0
    kept = 0
    mapped = 0

    # For dedup: key=(start_1based, umi, readlen_after_trim)
    seen = set()

    for h, seq, q in iter_fastq(args.fastq):
        total += 1
        seq_t = trim_adapter_3p(seq, args.adapter3)
        umi, insert, flags = extract_umi(seq_t, args.umi_length, args.umi_location, args.linker_seq)

        if args.linker_seq and args.linker_seq in seq_t:
            linker_found += 1

        if not insert or len(insert) < 15:
            continue
        kept += 1

        if umi:
            umi_hist[umi] += 1
            for i,ch in enumerate(umi[:args.umi_length]):
                umi_pos_counts[i][ch] += 1

        start0 = best_align_start(insert, ref, args.max_mismatches)
        if start0 is None:
            continue
        mapped += 1
        pos1 = start0 + 1
        raw_counts[(tid, pos1)] += 1

        key = (pos1, umi, len(insert))
        if key not in seen:
            seen.add(key)
            dedup_counts[(tid, pos1)] += 1

    # write counts CSVs
    L = len(ref)
    def write_counts(path, counts):
        rows = []
        for p in range(1, L+1):
            rows.append({"transcript_id": tid, "position_1based": p, "count": counts.get((tid,p), 0)})
        pd.DataFrame(rows).to_csv(path, index=False)

    write_counts("counts_raw.csv", raw_counts)
    write_counts("counts_dedup.csv", dedup_counts)

    # plot histograms (position vs count)
    xs = list(range(1, L+1))
    yr = [raw_counts.get((tid,p),0) for p in xs]
    yd = [dedup_counts.get((tid,p),0) for p in xs]

    fig, axes = plt.subplots(1,2, figsize=(12,3), sharey=True)
    axes[0].bar(xs, yr, width=1.0)
    axes[0].set_title("Raw 5' start counts")
    axes[0].set_xlabel("Position (1-based)")
    axes[0].set_ylabel("Count")
    axes[1].bar(xs, yd, width=1.0)
    axes[1].set_title("Deduplicated 5' start counts")
    axes[1].set_xlabel("Position (1-based)")
    plt.tight_layout()
    plt.savefig("starts_hist_raw_vs_dedup.png", dpi=200)

    # UMI QC summary
    unique_umis = len(umi_hist)
    top_umi, top_umi_n = ("",0) if not umi_hist else umi_hist.most_common(1)[0]
    top_frac = 0.0 if sum(umi_hist.values())==0 else top_umi_n/sum(umi_hist.values())
    entropies = [entropy_base_counts(c) for c in umi_pos_counts]

    # minimal HTML report
    html = []
    html.append(f"<h1>Ribo-seq toy single-transcript report: {tid}</h1>")
    html.append("<h2>Inputs / parameters</h2>")
    html.append(f"<p>UMI_LENGTH={args.umi_length}; UMI_LOCATION={args.umi_location}; LINKER_SEQ={args.linker_seq}; ADAPTER_3P_SEQ={args.adapter3}</p>")
    html.append("<h2>Read processing</h2>")
    html.append(f"<p>Total reads: {total}<br>Kept after trim/UMI/minlen: {kept}<br>Mapped: {mapped}</p>")
    if args.linker_seq:
        html.append(f"<p>Reads containing LINKER_SEQ anywhere (crude): {linker_found} / {total}</p>")
    html.append("<h2>UMI QC</h2>")
    html.append(f"<p>Unique UMIs observed: {unique_umis}<br>Top UMI: {top_umi} ({top_umi_n} reads; fraction {top_frac:.3f})</p>")
    html.append("<p>Per-position UMI entropy (bits): " + ", ".join([f"{e:.2f}" for e in entropies]) + "</p>")
    html.append("<h2>5' start histogram</h2>")
    html.append('<img src="starts_hist_raw_vs_dedup.png" width="1000">')
    with open("report.html","w") as out:
        out.write("\n".join(html))

if __name__ == "__main__":
    main()
```

**What this produces (and how it matches the required deliverables):**
- `counts_raw.csv` / `counts_dedup.csv`: three columns: `transcript_id, position_1based, count` for every position 1..L.
- `starts_hist_raw_vs_dedup.png`: side-by-side histograms.
- `report.html`: self-contained QC summary (parameters, read survival, mapping, UMI diversity, plot).

---

### B. Minimal QC interpretation framework for this pilot (single transcript)

Because this is a single-transcript toy dataset with a few hundred reads, interpretation should be conservative and QC-first:

**1) UMI sanity**
- If `unique_umis` is extremely small (e.g., single digits to tens) and **top UMI fraction is very high** (e.g., >0.2), that supports Incident D-type failure (wrong extraction or bad oligo), and deduplicated profiles should not be trusted until UMI parsing is corrected.

**2) Adapter/linker structure**
- If `LINKER_SEQ` is expected by protocol but is rarely observed in raw reads (or only observed in primer-dimer-like reads), that supports Incident E-type ligation/library-structure problems.

**3) Footprint-like positional signal**
- Peaks that remain after deduplication are more likely to reflect true molecule diversity (potentially footprint signal), whereas peaks that collapse almost entirely suggest PCR duplication or UMI problems.

---

### C. Periodicity analysis (done in a way that avoids overclaiming)
For a single transcript, periodicity requires a CDS definition. If `protocol.md` or accompanying annotation provides CDS start/stop for `toy_gene`, periodicity can be computed directly. If not provided, **the report should explicitly state** that CDS coordinates were inferred computationally (e.g., longest ORF scan) and treated as provisional.

**Recommended (optional) extension to the script (still within scope):**
- Infer the longest ORF in `reference.fa` (start ATG, stop TAA/TAG/TGA).  
- For offsets 10–15 nt, compute frame distribution of `(5′start + offset - CDS_start) % 3` for reads whose inferred P-site lies within the CDS.  
- Report the best-offset frame enrichment.  
This explicitly addresses the risk that “weak periodicity” is due to choosing the wrong offset, while still flagging that inferred CDS/offset adds uncertainty.

---

### D. Written interpretation + 2–4 follow-up checks (concrete and incident-linked)

#### Interpretation (what is biologically meaningful if present)
On this toy dataset, the only potentially biologically meaningful observation is **a reproducible, deduplication-resistant pattern of 5′ start enrichment** along `toy_gene` that is not explained by adapter/UMI artifacts. Any strong conclusion about translation dynamics (stalling, initiation peaks) is not warranted without robust UMI diversity, correct library structure, and (ideally) periodicity support.

#### Follow-up checks / next steps (2–4)
1. **UMI parsing differential test (Incident D control):** run the pipeline under at least 2–3 UMI-location hypotheses (5′ vs adjacent-to-linker vs 3′) and select the one with realistic UMI entropy and diversity.
2. **Linker-prefix frequency check (Incident E control):** quantify the expected linker sequence occurrence in raw reads (and after trimming); low frequency flags ligation/library-structure failure.
3. **Length/insert filtering sensitivity (Incident C control):** re-run counts and periodicity (if computed) restricted to a plausible footprint insert-length range; assess whether interpretability improves when long inserts are excluded.
4. **Dedup robustness check:** compare peak positions in raw vs dedup counts; if the profile shape changes drastically upon dedup, treat the raw profile as PCR/UMI-influenced rather than biological.

---

## Cross-incident validation and prevention plan (workflow-level, actionable)
1. **Pre-PCR inhibitor gate (Incidents A/B):** enforce a cleanup checklist and require passing A260/230 (or equivalent) and consistent qPCR efficiency before proceeding.
2. **Footprint-size gate (Incident C):** require narrow protected-fragment size distribution and exclude substantial >40 nt material.
3. **Library-structure gate (Incidents D/E):** before dedup/quantification, require:
   - high expected linker/adapter structure rate, and
   - UMI complexity consistent with the designed UMI length (entropy/diversity checks).
4. **Protocol hardening:** any step in `protocol.md` that depends on operator judgment (bead drying, gel slice boundaries, UMI placement) must be rewritten with explicit parameters and QC acceptance thresholds to minimize operator-dependent outcomes.